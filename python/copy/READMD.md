# 할당 얕은 복사 깊은 복사

### 22일 (어제) 작성했던 복사에 대한 내용

**얕은 복사**
- 객체를 새로운 변수로 복사하지만, 기존 객체의 주소값을 복사해옴
    - 원본값 훼손 가능성이 있음
    - a = b 이런식으로 나타냄

**깊은 복사**
- 객체 자체를 그대로 복사
    - a = b.copy() 함수 사용해서 나타냄

----

> 다시정리
### 할당
```
a = [10, 2, 3]
b = a
b[0] = 100
print(a)  # [100, 2, 3] → a도 바뀜!
```
`a = b` 는 할당
b 와 a는 완전히 같은 객체를 가리킨다.
하나를 바꾸면 다른 것도 함께 바뀌게 된다.

### 얕은 복사
```
import copy
a = [1, 2, 3]
b = a.copy()         # 또는 b = list(a), b = a[:]

alist = [
    [1, 2],
    [3, 4],
]

blist = alist[:] # 복사 / alist.copy(blist) 와 같음

print(blist) #[[1, 2], [3, 4]]
print(alist) #[[1, 2], [3, 4]]


alist[0] = [5, 6]
alist[1][0] = 7

print('-'*30)
print(alist)
print(alist[0])
print(alist[1][0])

print(blist)
print(blist[0]) # 새통에 넣은 인덱스라 값이 안 바뀜 
print(blist[1][0]) # 들어 있던 주소값은 a에서 복사해온 주소값이라 값이ㅏ 바뀜



# 통은 새건데 들어가 있는 데이터는 복사해온 주소임 ...
# 출력값
# ------------------------------
# [[5, 6], [7, 4]]
# [5, 6]
# 7
# [[1, 2], [7, 4]]
# [1, 2]
# 7

```
b 는 a 와 같은 값들을 갖는 새로운 객체가 된다
바깥 리스트는 복사되지만 , 요소들은 같은 객체를 참조한다.
1차 배열에서는 다른 것 처럼 보이지만
2차 배열로 들어가게 되면 문제가 생긴다.

얕은 복사는 새로운 옷을 입은 나... ?
같은 느낌이다 
내장은 같으니까 . . 

### 깊은 복사
```
# 깊은 복사 하기
import copy 
blist = copy.deepcopy(alist)
```
