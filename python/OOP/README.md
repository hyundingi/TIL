#### 250730 -31

# OOP 

## 절차 지향 프로그래밍

: "어떤 순서로 처리할까?"

- 순차적 명령어 실행
- 데이터와 함수의 분리
    - 데이터와 해당 데이터를 처리하는 함수가 분리
    - 함수 호출의 흐름이 중요
- 데이터를 재사용하기보다는 처음부터 끝까지 실행되는 결과물이 중요

*한계*
1. 복잡성 증가 
    - 프로그램 규모가 커질수록 데이터와 함수의 관리가 어려움
    - 전역 변수 증가로 인한 관리의 어려움
2. 유지 보수 문제
    - 코드 수정 시 영향 범위 파악이 어려움


## 객체 지향 프로그래밍

: "어떤 객체가 이 문제를 해결할까?"
  " 이 객체는 어떤 속성과 기능을 가질까?"

- 데이터와 그 데이터를 처리하는 함수를 하나의 단위 객체로 묶어서 조직적으로 관리함
    - 코드의 구조화와 재사용성을 높임
- 데이터와 메서드의 결합
    - 객체 간 상호작용과 메시지 전달이 중요 

주요 키워드 
- **클래스**
- **인스턴스(객체)**
    - 인스턴스 = 객체는 아님 
    - 인스턴스는 객체에 포함되는 개념 
    - 무슨 타입의 인스턴스인지 알고 있어야함.

### 객체 (object)

실제로 존재하는 사물을 추상화한 것

- 속성 (변수)
- 동작 (메서드)
- 고유성 
    - 각 객체는 고유한 특성을 가짐


### 클래스

객체를 만들기 위한 설계도
데이터와 기능을 함께 묶는 방법을 제공

- 데이터 (변수/속성)
- 기능 (함수/메서드)

을 함께 정의 하는 도구

### 인스턴스

클래스를 통해 생성된 객체
* 같은 클래스로 여러 인스턴스를 만들 수 있으며, 각 인스턴스는 클래스 구조를 따라 동작함 (서로 독립된 데이터를 가질 수 있음)

**[클래스와 인스턴스]**

`'hello', '파이썬' 등 .. ` = 문자열 타입(클래스) 의 객체(인스턴스)
`[1, 2, 3], [1], []` = 문자열 타입(클래스)의 객체(인스턴스)

**[인스턴스와 메서드]**

`'hello'.upper()` = 문자열.대문자로() > 객체.행동() > 인스턴스.메서드()


!! 하나의 객체는 특정 클래스의 인스턴스 이다. !!

### 클래스 구조

#### 생성자 메서드

- 인스턴스 생성 시 자동 호출되는 특별한 메서드
- 새로운 객체를 만들 때 필요한 초기값을 설정
- `__init__` 이라는 이름의 메서드로 정의

#### 인스턴스 변수(속성)

- 각 인스턴스별 고유한 속성
- self.변수명 형태로 정의
- 인스턴스마다 독립적인 값 유지

#### 클래스 변수(속성)

- 모든 인스턴스가 공유하는 속성
- 클래스 내부에서 직접 정의

```python
class Circle:
    pi = 3.14 # 클래스 변수

    def __init__(self, radius):  # 생성자 메서드
        self.radius = radius   # 인스턴스 변수
```


### 메서드

- 클래스 내부에 정의된 함수
- 해당 객체가 어떻게 동작할지를 정의

**메서드 종류**
1. 인스턴스 메서드
2. 클래스 메서드
3. 스태틱 메서드


#### 인스턴스 메서드

- 인스턴스의 상태를 조작하거나 동작을 수행함

*구조*
- 반드시 첫번째 인자로 인스턴스 자신(self)을 받음
- 인스턴스의 속성에 접근하거나 변경 가능

```python
class Counter:
    def __init__(self):
        self.count = 0
    
    def increment(self):
        self.count += 1

c = Count()
c.increment() # 인스턴스 메서드 활용 / 속성에 접근하여 값을 변경함
```

#### 생성자 메서드

위에서 설명함

#### 클래스 메서드

클래스 변수를 조작하거나 클래스 레벨의 동작을 수행함

`@classmethod` 를 사용하면 클래스 자체를 호출할 수 있고, 그 안에서 클래스 변수를 변경하거나 전체 동작을 정의할 수 있음

```python
class Animal:
    num_of_animal = 0 # 클래스 변수

    # 클래스 메서드 활용
    class Pet(Dog, Cat):
        @classmethod
        def access_num_of_animal(cls):
            return f'{Animal.num_of_animal}'
    
    # 클래스 메서드 안 쓰면
    def __init__(self):
        Animal.access_num_of_animal()
```


#### 스태틱 메서드

- 클래스, 인스턴스와 상관없이 독립적으로 동작하는 메서드
- ex) 점수만 있으면 시험 점수 등급 계산 결과를 낼 수 있는 것과 같은 독립적인 기능
- `@staticmethod` 를 사용


- 호출 시 자동으로 전달 받는 인자가 없음
- 인스턴스나 클래스 속성에 직접 접근하지 않는 도우미 함수

```python
class Math:
    @staticmethod
    def add(a, b):
        return a + b

print(Math.add(3, 5))
```

<입출금 은행계좌 실습 해보기>

----

**클래스가 사용해야 할 것**
- 클래스 메서드
- 스태틱 메서드

**인스턴스가 사용헤야 할 것**
- 인스턴스 메서드

* 공통 설정값을 바꾸거나 유틸리티성 처리를 할 땐 *클래스/스태틱 메서드*
* 개별 객체의 상태를 다룰 땐 반드시 인스턴스 메서드
* *"무엇을 바꾸는가?"*가 메서드 선택의 기준!


### 매직 메서드

- __ 가 있는 메서드는 특수한 동작을 위해 만들어진 메서드

```python
def __init__(self, radius):
def __str__(self):
def __len__(self):
def __lt__(self):
def __le__(self):

```

## 상속

한 클래스(부모)의 속성과 메서드를 다른 클래스(자식)가 물려받는 것

- 위쪽에 있는 부모 클래스가 본인의 속성과 메서드를 아래쪽에 있는 자식에게 넘겨주는 것

---

상속이 필요한 이유 ?

- 코드 재사용
    - 생속을 통해 기존 클래스의 속성과 메서드를 재사용할 수 있음
    - 기존 클래스를 수정하지 않고도 기능 확장 가능

- 계층 구조
    - 상속을 통해 클래스들 간의 계층 구조 형성
    - 더 구체적인 클래스를 만들 수 있음

- 유지 보수의 용이성
    - 기존 클래스의 수정이 필요한 경우 해당 클래스만 수정하면 되므로 유지 보수가 용이해짐
    - 코드의 일관성 유지 / 수정이 필요한 범위를 최소화

```python
# 예시 
class Animal:
	def eat(self):
		print('먹는중')
		
class Dog(Animal):
	def bark(self):
		print('멍멍')

my_dog = Dog()
my_dog.bark() # 멍멍
my_dog.eat() # 먹는 중
```

부모 클래스 메서드 사용이 가능하다.


### 클래스 상속

### 메서드 오버라이딩

부모 클래스의 메서드를 같은 이름 , 같은 파라미터 구조로 재정의하는 것

- 자식 클래스에서 메서드를 다시 정의하면 부모 클래스의 메서드 대신 자식 클래스의 메서드가 실행됨

- 동일한 이름과 매개변수 사용
    - 부모 클래스의 기능을 유지하면서도 일부 동작을 맞춤형으로 바꾸고 싶을 때 유용

- 파이썬은 오버로딩 안 됨


### 다중 상속

- 둘 이상의 상위 클래스로부터 여러 행동이나 특징을 상속받을 수 있음
- 중복된 속성이나 메서드가 있는 경우 상속 순서에 의해 결정

**MRO**
- 파이썬이 메서드를 찾는 순서에 대한 규칙
- 기본적으로 왼쪽에서 오른쪽(상속 순서), 계층 구조에서 중복되는 클래스는 한 번만 확인

```python
class D(B, C):
	pass

# 탐색 순서 D > B > C
```

**`super()`** 
- 메서드 해석 순서에 따라 현재 클래스의 부모 클래스의 메서드나 속성에 접근할 수 있게 해주는 내장 함수

- 단순히 부모 클래스의 메서드를 호출하기 위한 용도 뿐만 아니라 다중 상속에도 올바른 순서를 따라 상위 클래스의 메서드를 찾기 위해 사용함

1. 단일 상속 구조
    ```python
    class Student(Person):
        def __init__(self, name):
            super().__init__
    ```
    - 고유의 속성을 가져오고 해당 클래스에서 추가로 사용하고 싶은 생성자를 추가할 수 있음
    - 부모 클래스가 교체되어도 super() 사용하면 코드 수정이 더 적게 필요

2. 다중 상속 구조


## 에러와 예외

### 에러 

- 프로그램 실행 중에 발생하는 예외 상황
    - invalid syntax (문법 오류)
    - assign to literal (잘못된 할당)


### 예외

- 프로그램 실행 중에 감지되는 에러
    - 프로그램이 잘못된 동작을 시도할 때 자동으로 감지됨
    - ex ) 리스트에 없는 값을 꺼내려 하면 예외 발생



- 내장 예외 
    - `zeroDivisionError` - 0으로 값을 나누려고 할 때
    - `NameError` - 지역 또는 전역 이름을 찾을 수 없을 때
    - `TypeError` - 타입 불일치, 인자 누락, 인자 초과, 인자 타입 불일치 등
    - `ValueError` - 연산이나 함수에 문제가 없지만 부적절한 값을 가진 인자를 받았고, 상황이 indexError 처럼 더 구체적인 예외로 설명되지 않는 경우
    - `indexError` - 시퀀스 인덱스가 범위를 벗어남
    - `keyError` - 딕셔너리에 해당 키가 존재하지 않음
    - `ModuleNotFoundError` - 모듈을 찾을 수 없을 때 


**예외처리**
-  try - catch 구문

```python
try: # 예외가 발생할 수 있는 코드 작성
	result = 10 / 0

except ZeroDivisionError as error:  # 예외가 발생했을 때 실행할 코드 작성
	print(f'{error} : 0으로 나눌 수 없음')

# 모든 예외 클래스이 최상위 클래스
except Exception:
	pass

else: # 예외가 발생하지 않았을 때 실행할 코드 작성
    pass

finally: # 예외 발생 여부와 상관없이 항상 실행할 코드
    pass
```
