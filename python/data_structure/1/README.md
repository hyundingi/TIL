# Data Structure


학습 목표
- 데이터 구조의 개념과 필요성 이해
- 문자열의 다양한 메서드를 활용하여 텍스트 처리
- 리스트의 메서드를 활용하여 추가, 삭제, 탐색, 정렬하기
- 객체, 참조, 가변성의 개념 이해 
- 얕은 복사와 깊은 복사의 차이 이해
- 리스트 컴프리헨션
- 메서드 체이닝 


-------

### 데이터 구조


: 여러 데이터를 효과적으로 사용 관리하기 위한 구조

<구조의 활용>

- 메서드
: 객체에 속한 함수
    - 문자열, 리스트, 딕셔너리 등 각 데이터 구조의 메서드를 호출하여 다양한 기능 활용하기


*문자열, 리스트, 딕셔너리 등 파이썬의 다양한 데이터 구조는 저마다 고유한 메서드를 가진다.*


**메서드는 어딘가(클래스)에 속해 있는 함수이며 각 데이터 타입별로 다양한 기능을 가진 메서드가 존재한다.**


은연 중에 사용해왔던 것으로 `type()` 함수가 있는데,

출력값이 `<class: ... >` 으로 나왔던 것을 기억할 것이다.

이것은 ...도 클래스 였다는 것을 확인 가능하다.

---
메서드 호출하기
`데이터 타입 객체.메서드()`


#### 시퀀스 데이터 구조


**문자열**


- 문자열 조회 / 탐색 및 검증 메서드
```
.find(x) # x의 첫 번째 위치를 반환. 없으면 -1
.index(x) # x의 첫번째 위치를 반환. 없으면 오류발생
.isupper() # 문자열 내의 모든 문자가 대문자인지 확인
.islower() # 문자열 내의 모든 문자가 소문자인지 확인
.isalpha() # 문자열 내의 모든 문자가 알파벳인지 확인 
```


- 문자열 조작 메서드 (새로운 문자열을 반환한다)

*문자열은 불변 객체라 기존 값이 변경되는 것이 아니라 새로운 문자열로 반환된다.*

```
.replace(old, new[, count]) # 바꿀 대상 글자를 새로운 글자로 바꿔서 반환
text = 'hello, python'
text.replace('hello', 'Hello') # Hello, python
text.replace('o', 'b', 1) # hellb, python < 하나만 바꿈

.strip([chars]) # 문자열의 시작과 끝에 있는 공백 혹은 지정한 문자 제거
.split() # sep을 구분자로 사용하여 문자열에 있는 단어들의 리스트를 반환
.join() # 반복가능한 객체의 문자열을 연결한 문자열 반환

words = ['hello', 'world']
text = '--'.join(words) # 구분자.join(iterable 인자)
print(text) # hello--world
```
```
.capitalize() # 첫글자만 대문자 나머지는 소문자
.title() # 단어의 첫글자를 대문자
.upper() # 모두 대문자
.lower() # 모두 소문자
.swapcase() #소문자 > 대문자 , 대문자 > 소문
```


**리스트**

- 리스트 값 추가 및 삭제 메서드

```
.append(x) # 리스트 마지막 항목에 x 추가
.extend(m) # 리스트 마지막 항목에 iterable 객체를 풀어서 넣음 / 반복 가능한 객체가 아니면 추가할 수 없음
my_list = [1, 2]
my_list.extend([3, 4])
print(my_list) # [1, 2, 3, 4]

.pop() # 마지막 항목 반환 후 제거 
.pop(i) # 리스트의 인덱스 i에 있는 항목 반환 후 제거

.insert(i, x) # i에 항목 x 삽입
.remove(x) # 첫번째 x를 제거  항목이 존재하지 않을 경우 오류
```

- list 에 값이 있나 없나 확인할 때
    - `if not list:` 사용.
    - `len(list) == 0 ` 도 사용 가능하지만 별로 권장하지 않는다고 한다.

------

오늘 실습 내용 중 튜플을 인자로 넘겨 받아 정렬 후 다시 튜플로 남겨주는 함수를 생성했어야 했다.

하지만 튜플은 불변 객체이기 때문에 정렬이 안되고, append 또한 안 된다.

이것을 해결하기 위해,
1. 튜플을 인자로 넘겨 받아 `list()` 메서드를 활용하여 튜플을 리스트 객체로 변경
2. `list` 객체로 변경된 리스트를 `sort()`
3. 정렬한 리스트 요소들을 하나하나 새로운 튜플에 추가
```
for i in arr:
    new_tuple = new_tuple + (i,)
```
빈 튜플에 (i) 만 들어가게 되면 tuple이 되지 않고 int가 되기 때문에 

뒤에 쉼표를 넣어 계속 값을 받도록 설정하였다.

----


- 리스트 탐색 및 정렬 메서드

```
.reverse() # 리스트의 순서를 역순으로 변경 (정렬 아)
.sort() # 리스트를 정렬 / 기본값 오름차순 

.index(x) # 리스트에서 첫번재로 일치하는 항목 x의 인덱스를 반환
.count(x) # 리스트에서 항목의 x의 개수를 반환
```



### 복사

#### 객체와 참조

**Mutable(가변) 객체**

: 생성 후 내용을 변경할 수 있는 객체

- 리스트, 딕셔너리, 셋
- 객체의 내용이 변경되어도 같은 메모리 주소를 유지

```
 a = [1, 2]
 a = b
 b[0] = 100
 print(a) # [100, 2]
 print(b) # [100, 2]
 print(a is b) # True
```



**Immutable(불변) 객체**

: 생성 후 내용을 변경할 수 없는 객체

- 정수, 실수, 문자열, 튜플
- 새로운 값을 할당하면 새로운 객체가 생성됨.
- 변수는 새 객체를 참조하게 됨.

```
a = 20
b = a 
b = 10

print(a) # 20
print(b) # 10
print(a is b) # False
```



변수 할당

: 객체에 대한 참조를 생성하는 과정

- 메모리 주소를 가리키는 label 역할을 함
- '=' 연산자를 사용해서 변수에 값을 할당한다.
- 할당 시 새로운 객체가 생성되거나, 기존 객체에 대한 참조가 생성된다.


*할당되는 값이 새로운 객체일 경우*

- 해당 객체를 먼저 메모리에 만들고, 변수가 그 객체를 가리키도록 함

```
# a에는 할당된 값이 없었던 상태
# 여기서 객체 : 10 / 변수 : a
a = 10 
```


*기존에 있던 객체일 경우*

- 이미 메모리에 존재하는 객체를 변수에 할당하면, 새로운 객체를 만들지 않고 해당 객체에 대한 참조만 생성함


`id()` 함수를 사용하여 객체의 메모리 주소 확인 가능



#### 얕은 복사
객체의 최상위 요소만 새로운 메모리에 복사하는 방법

내부에 중첩된 객체가 있다면 그 객체의 참조만 복사됨.

*주의사항*

- 얕은 복사 후 중첩된 리스트나 딕셔너리 같은 가변 객체를 수정하면, 원본 객체와 복사본 객체가 함께 변경됨
    - 이는 복사본의 중첩 객체가 여전히 원본 객체의 중첩 객체를 참조하고 있기 때문

```
# 얕은 복사 구현하기

# 1. 리스트 슬라이싱 
a = [1, 2, [3, 4]]
b = a[:]

# 2. copy()
b = a.copy()

# 3. list() 함수
b = list(a)

b[0] = 100
print(a) # [1, 2, [3, 4]]
print(b) # [100, 2, [3, 4]]

b[2][1] = 100
print(a) # [1, 2, [3, 100]] # 중첩 객체는 아직 원본 객체를 참조중
print(b) # [100, 2, [3, 100]]
```



#### 깊은 복사
객체의 모든 수준의 요소를 새로운 메모리에 복사함

중첩된 객체까지 모두 새로운 객체로 생성

```
# 깊은 복사 구현

import copy
b = copy.deepcopy(a)
```



### 리스트 컴프리헨션

간격하고 효율적인 리스트 생성 방법

사용할 줄은 알고 있되, 남용하지 말자 ...

```
# 리스트 컴프리헨션의 구조
[표현식 for 변수 in 순회 가능한 객체 if 조건]

# 사용 전
list = [3, 4, 5]
new_list = []

for num in list:
	new_list.append(num ** 2)

print(new_list) # [9, 16, 25]

# 사용 후 
new_list = [num ** 2 for num in list]
print(new_list) # [9, 16, 25]
```


앞으로 많이 사용하게 될

```
# 2차원 배열 생성
data = [[0] * 5 for _ in range(5)]
data = [[0 for _ in range(5)] for _ in range(5)]
```


### 메서드 체이닝

여러 메서드를 연속해서 호출하는 방식

```
# 문자열에서
text = 'hello'
result = text.swapcase().replace('H', 'h')
print(result) # hELLO

# 리스트에서
numbers = [3, 1, 4, 1]
result = numbers.copy().sort()
print(numbers) # [3, 1, 4, 1] 원본은 변경되지 않음
print(result) # None sort() 메서더는 None 을 반환하기 때문에

# 올바른 예시
sorted_numbers = sorted(numbers.copy())
print(sorted_numbers) # [1, 1, 3, 4]
```

메서드가 객체를 반환할 때만 체이닝이 가능하다.

None 을 반환하는 메서드는 체이닝이 불가하다



### 문자 유형 판별 메서드

문자열에 포함된 문자들의 유형을 판별하는 메서드

```
.isdecimal() # 문자열이 모두 숫자 문자(0~9)로만 이루어져 있어야 함
.isdigit() # 위에와 비슷하지만 유니코드 숫자도 인식 
.isnumeric() # 위에와 유사하지만 몇가지 추가적인 유니코드 문자들을 인식(분수, 지수, 루트 기호도 숫자로 인식)
```



