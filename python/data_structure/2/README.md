# Data Structure - 2


- 딕셔너리와 세트의 개념과 필요성 설명
- get, update, pop 등 딕셔너리 메서드 사용
- union, intersection, difference 등 세트 집합 연산으로 중복 제거 및 관계 분석
- 해시 테이블과 hashable의 원리 이해
- EBNF 메타기호 ([ ])를 해석해 공식 문서 읽기


-------


## 딕셔너리

키를 통한 값의 삽입, 삭제, 검색이 데이터의 크기와 관계없이 매우 빠르다 (이유는 해시테이블 참고)
**키**는 hashable한 고유 값이어야 하지만, **값**은 중복이 가능하고 어떤 자료형도 저장할 수 있다.

### 딕셔너리 메서드의 종류

- 값 반환
```
딕['k'] # 키에 연결된 값을 반환 (키가 없으면 에러)
.get('k') # 키에 연결된 값을 반환 (키가 없으면 None 반환)
.get('k', v) # 키에 연결된 값을 반환하거나 키가 없으면 기본 값으로 v 반환
```


- 객체 반환
```
person = {'name': 'alice', 'age': 20}
# 딕셔너리의 키를 모은 객체 반환 
.keys() # ['name', 'age']

# 딕셔너리의 값을 모은 객체 반환
.values() # ['alice', 20]

# 키 값 쌍을 모은 객체 반환
.items() # [('name', 'alice'), ('age', 25)]
```


- 제거 
```
.pop(k) # k를 제거하고 연결됐던 값을 반환 (없으면 오류)
.pop(k, v) # k를 제거하고 연결됐던 값을 반환 (없으면 v를 반환)
.clear() # 딕셔너리 모든 키 값 쌍 제거
```

여기에서 `clear()` 는 `d = {}` 와 같이 빈 객체를 재할당 하는 것과 다르다 

그 이유도 아래 해시테이블을 참고하자.


- 갱신, 추가
```
.setdefault(key[,default]) # 키와 연결된 값을 반환. 
# 키가 없다면, default와 연결한 키를 딕셔너리에 추가하고 default를 반환함 !!!!!!
# 유사 조건문 .. ㅎ

.update([other]) # other가 제공하는 키/ 값 쌍으로 딕셔너리를 갱신하고, 
								 # 기존 키는 덮어씀 없으면 추가함

other_person = {'name': 'jane', 'gender':'women'}
preson.update(other_person)
print(person) # {'name': 'jane', 'age': 20, 'gender':'women'}
```

[더 다양한 자료는 공식문서 참조](https://docs.python.org/3.11/library/stdtypes.html#dict)

## 세트


**고유한 항목**들의 **정렬되지 않은** 컬렉션이다.

내부적으로 해시 테이블을 사용하여 데이터를 저장한다.

항목의 고유성을 효율적으로 보장하며, 항목의 추가, 삭제, 존재 여부 확인이 데이터의 크기에 상관없이 매우 빠르다.

합집합, 교집합, 차집합 등 수학적인 집합 연산을 간편하게 수행할 수 있다.

*하지만  `리스트 > 세트 > 리스트` 로 변경했을 때 순서가 유지되지 않는다는 점은 참고*


### 세트 메서드의 종류


- 추가, 삭제
```
.add(x) # 세트에 항목 x를 추가. 이미 x가 있다면 변화 없음
.remove(x) # 세트에서 항목 x를 제거. 항목 x가 없을 경우 key error

.update(iterable) # 세트 s에 다른 iterable 요소를 추가
.pop() # 임의의 항목을 반환하고, 해당 항목을 제거 (랜덤과는 다르다)
.discard(X) # 항목 x를 제거. 에러 없음
.clear() # 모든 항목 제거
```

set 데이터에 정수만 있을 때 pop을 하게 되면 순서가 거의 고정된다.
하지만 문자가 섞여있을 경우엔 해시 난수화 이슈로 실행마다 순서가 달라진다.
이것은 set 내부적으로 해시 테이블(버킷)을 참조하기 때문이다.
*해시 난수화에 대해서는 아래*


- 집합 메서드
```
# 1에는 들어있지만 2에는 없는 항목으로 세트를 생성 후 반환
set1.difference(set2) 
set1 - set2

# 모두 들어있는 항목으로 세트 생성 후 반환
set1.intersection(set2) 
set1 & set2

# set1의 항목이 모두 set2에 있으면 true 반환
set1.issubset(set2)
set1 <= set2

# set1이 set2의 항목을 모두 포함하면 true 반환
set1.issuperset(set2) 
set1 >= set2

# set1이 set2에 혹은 둘 다 들어있는 항목으로 세트를 생성 후 반환
set1.union(set2)
set1|set2
```

----

실습 중 헤맨 부분

```
result = set()
for s in sets:
	# result.union(s)
	result = result.union(s) 
return result 
```

처음에는 `result.union(s)` 이렇게 했더니 result에 아무것도 들어있지 않았다.

알고보니 union도 연산이기 때문에 위에 처럼 `result = result.union(s)` 값을 받아줄 객체가 필요했다.

`1+2 print(result)` 같은 짓 했다 .. 머쓱..

----

## 해시테이블 (버킷)

키와 값을 짝지어 저장하는 자료 구조

키를 해시함수를 통해 해시 값으로 변환한다.

변환된 해시 값을 인덱스로 삼아 데이터를 저장하거나 찾는다. 
- 이로 인해 검색, 삽입, 삭제를 매우 빠르게 수행 가능하다.
    - 리스트는 무조건 다 순회해야하지만, 키로 데이터를 찾으면 해당 고유값으로 보내준다.(그래서 더 빠름)
[추가 내용은 아래에]

**여기서 고유한 값으로 변환하는 과정을 *해시* 한다고 한다.**


## 해시

임의의 크기를 가진 데이터를 고정된 크기의 고유한 값으로 변환하는 것 

생성된 해시 값은 해당 데이터를 식별하는 *지문* 역할을 함.

파이썬에서는 이 해시 값을 이용해 해시 테이블에 데이터를 저장함

1. 고유한 값으로 변환(해시 값 - 고유한 정수)
2. 해시 값을 사용하여 해시 테이블에 데이터를 저장함
3. 이로 인해 검색, 삽입, 삭제롤 매우 빠르게 수행함


### 해시 함수

임의 길이 데이터를 입력 받아 고정 길이(정수)로 변환해 주는 함수

여기서 **정수**가 바로 해시 값이다.

여기서 데이터의 정수값은 해시 값이 자기 자신과 동일하거나 단순 계산으로 고정된다.
*정수는 자기 자리를 유지할 수 있다.*

만약 데이터에 문자와 정수가 섞여있다면 정수는 자기 자리를 유지하는데,
문자는 해시 계산 시 파이썬의 해시 난수화가 적용되므로 실행마다 순서가 달라진다.

그 예로,
1. 같은 정수는 항상 같은 해시 값을 가진다.
2. `hash(1)` 은 여러번 호출해도 결과가 동일하다.
3. 문자열은 해시시 파이썬 인터프리터 시작 때 설정되는 난수 시드 때문에 달라질 수 있다.
`print(hash('a')) # 실행시마다 다름`

**여기서 해시 난수화란,**

해시를 계산할 때 사용하는 난수 시드가 달라지는 것인데,
이것은 해시 함수가 매번 바뀌는 것이 아니라, 파이썬 프로세스가 새로 시작될 때마다 바뀌는 난수 시드 때문이다.
이로 인해 동일한 데이터라도 매번 해시 값이 달라져 결과적으로 버킷 배치가 달라진다.



### 해시 값을 이용하는 것이 빠른 이유

- 키를 입력 받아 데이터를 저장하거나 찾을 배열의 정확한 인덱스를 즉시 계산한다.
	- 책의 제목 (키)을 알면 색인 (해시 함수)을 통해 페이지 번호 (인덱스)를 바로 알아내고, 해당 페이지 (배열 위치)로 곧바로 이동하여 내용을 찾는 것과 같다.


### 셋의 요소와 딕셔너리 키, 해시 테이블의 관계

#### set

- 각 요소를 해시 함수로 변환해 나온 해시 값에 맞춰 해시 테이블 내부 버킷에 위치 시킨다
- 셋은 순서대로가 아니라 버킷 위치 (인덱스)가 요소의 위치를 결정한다.
- 따라서 셋은 순서를 보장하지 않는다.

#### dict
- 키 : 정수(데이터가 들어있는 해시값) 형태가 된다.
- set 과 달리 삽입 순서는 유지된다.
	- 딕셔너리를 반복할 때 키를 추가한 순서대로 나온다는 것을 안다.


### hashable

`hash()` 함수에 넣어 해시 값을 구할 수 있는 객체를 의미한다.
해시 함수를 통해 고유한 해시 값을 만들 수 있고, 값이 변하지 않는 객체다.

- 대부분의 불변 타입은 해시 가능하다.
	- 생성 후 값 변경이 불가하기 때문에 항상 같은 해시 값을 유지한다.
	- 주로 딕셔너리의 키로 사용될 수 있는 타입들
	- int, float, str, tuple

- 가변형 객체는 기본적으로 해시 불가능 (hashable 하지 않다.)
	- list, dict, set

값이 변하면 해시 값도 달라질 수 있어 해시 테이블 무결성이 깨지게 된다.
> 해시 테이블은 동일키 > 동일 위치로 가정하고 빠른 검색을 수행하기 때문

hashable 객체가 필요한 이유
1. 해시 테이블 기반 자료 구조 사용
	- set의 요소 , dict의 키
	- 중복 방지, 빠른 검색, 빠른 조회

2. 불변성을 통한 일관된 해시 값
	- 한 번 해시 값이 정해지면 바뀌지 않아 테이블 무결성이 유지된다.

3. 안정성과 예측 가능성 유지
	- 동일한 데이터는 항상 동일한 해시 값을 반환 한다는 로직 단순화